import JSZip from 'jszip';
import { saveAs } from 'file-saver';

export const generatePPTX = async (formData, images = {}) => {
  try {
    // 1. Load the template
    const response = await fetch('/template.pptx');
    if (!response.ok) throw new Error('Failed to load template.pptx');
    const arrayBuffer = await response.arrayBuffer();

    // 2. Unzip the PPTX
    const zip = await JSZip.loadAsync(arrayBuffer);

    // 3. Identify slide files
    const slideFiles = Object.keys(zip.files).filter(fileName =>
      fileName.startsWith('ppt/slides/slide') && fileName.endsWith('.xml')
    );

    // 4. Iterate and Replace Text
    for (const fileName of slideFiles) {
      let content = await zip.file(fileName).async('string');

      // Simple string replacement for all keys in formData
      Object.entries(formData).forEach(([key, value]) => {
        const placeholder = `{{${key}}}`;
        const escapedValue = String(value || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&apos;');

        content = content.replaceAll(placeholder, escapedValue);
      });

      // Update the file in the zip
      zip.file(fileName, content);
    }

    // 5. Image Replacement Logic
    // We expect matches in this order:
    // 1. Google Map (Slide 1, Large)
    // 2. ACES (Slide 2, Large)
    // 3. Move Off (Slide 3, 1st Large)
    // 4..10. Sequence (Slide 3, subsequent Large)

    const imageTargets = [];
    const EMU_PER_INCH = 914400;

    // Sort slide files to ensure 1 -> 2 -> 3 order
    slideFiles.sort();

    for (const fileName of slideFiles) {
      const content = await zip.file(fileName).async('string');
      // Regex to process strictly in order
      const picRegex = /<p:pic>[\s\S]*?<\/p:pic>/g;
      let match;
      while ((match = picRegex.exec(content)) !== null) {
        const picBlock = match[0];
        const extMatch = /<a:ext cx="(\d+)" cy="(\d+)"/.exec(picBlock);
        if (extMatch) {
          const cx = parseInt(extMatch[1]);
          const cy = parseInt(extMatch[2]);

          // Filter: Width MUST be > 1 inch.
          // This captures the 2 main images (Sl 1 & 2) and the 8 sequence images (Sl 3)
          // while filtering out small icons (0.29 inch)
          if (cx > EMU_PER_INCH) {
            const blipMatch = /<a:blip[^>]*r:embed="([^"]+)"/.exec(picBlock);
            if (blipMatch) {
              imageTargets.push({
                slideFile: fileName,
                rId: blipMatch[1]
              });
            }
          }
        }
      }
    }

    // Map uploaded images to targets in specific order
    const orderedUploads = [
      images.googleMapPic,
      images.acesPic,
      images.moveOffPic,
      images.sftl1RedPic,
      images.sftl1GreenPic,
      images.sftl2RedPic,
      images.sftl2GreenPic,
      images.sftl3RedPic,
      images.sftl3GreenPic,
      images.arrivalPic
    ].filter(Boolean); // If user skips some, we just fill what we have in order? 
    // Actually, if we use filter(Boolean), skipping 'aces' would shift 'moveOff' into 'aces' slot.
    // Better to KEEP nulls and skip replacement if null, ensuring correct mapping?
    // But commonly users might not have all 10. The prompt implies specific slots.
    // Let's assume we map simply 1-to-1 with the targets found.
    // If I have 10 targets and 10 inputs, perfect.
    // If user uploads only "Arrival", and I use filter(Boolean), it goes to "Google Map" slot.
    // That's bad.

    // We should use the raw array and check each index.
    const rawUploads = [
      images.googleMapPic,
      images.acesPic,
      images.moveOffPic,
      images.sftl1RedPic,
      images.sftl1GreenPic,
      images.sftl2RedPic,
      images.sftl2GreenPic,
      images.sftl3RedPic,
      images.sftl3GreenPic,
      images.arrivalPic
    ];

    for (let i = 0; i < imageTargets.length; i++) {
      if (i >= rawUploads.length) break;

      const uploadFile = rawUploads[i];
      if (!uploadFile) continue; // Skip if user didn't upload this specific image

      const target = imageTargets[i];


      // Resolve rId to actual file path using _rels
      // slideFile: ppt/slides/slide1.xml -> rels: ppt/slides/_rels/slide1.xml.rels
      const relsFile = target.slideFile.replace('ppt/slides/', 'ppt/slides/_rels/') + '.rels';

      const relsContent = await zip.file(relsFile)?.async('string');
      if (!relsContent) continue;

      // Find Target for this rId
      // <Relationship Id="rId2" ... Target="../media/image1.jpeg" />
      // Regex is safe enough for reliable XML generated by PPT
      const relRegex = new RegExp(`Relationship[^>]*Id="${target.rId}"[^>]*Target="([^"]+)"`);
      const relMatch = relRegex.exec(relsContent);

      if (relMatch) {
        let targetPath = relMatch[1];
        // Resolve path. Usually "../media/file.ext" relative to "ppt/slides/"
        // So "ppt/slides/" + "../media/file.ext" -> "ppt/media/file.ext"
        // We can just look for "media/" in the target path
        if (targetPath.includes('media/')) {
          // Construct zip path: ppt/media/filename
          const fileName = targetPath.split('/').pop();
          const zipPath = `ppt/media/${fileName}`;

          // Read upload as ArrayBuffer
          const uploadBuffer = await uploadFile.arrayBuffer();

          // overwrite
          zip.file(zipPath, uploadBuffer);
          console.log(`Replaced ${zipPath} with user upload ${i + 1}`);
        }
      }
    }


    // 6. Generate Blob
    const content = await zip.generateAsync({ type: 'blob' });
    saveAs(content, `Incident_Report_${formData.incident_no || 'Draft'}.pptx`);

  } catch (error) {
    console.error('PPTX Generation Error:', error);
    throw error;
  }
};
