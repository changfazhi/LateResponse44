import React, { useState, useEffect } from 'react';
import { Upload, FileText, Download, RefreshCw, CheckCircle, AlertCircle, X, ChevronRight, LayoutTemplate, Save, Cloud, Loader2, Trash2, Image as ImageIcon, Replace, AlertTriangle } from 'lucide-react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, getDoc, onSnapshot } from 'firebase/firestore';

// --- Firebase Setup ---
const firebaseConfig = JSON.parse(__firebase_config);
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

// --- CONFIGURATION ---
const MAX_FILE_SIZE_BYTES = 5 * 1024 * 1024; 
const CHUNK_SIZE_CHARS = 800000; 

// SETTING: If you put a file named 'template.pptx' in your public/ folder, the app will load it automatically.
// Use forward slashes to avoid invalid Unicode escape sequences in JS strings on Windows paths.
const PRESET_TEMPLATE_PATH = "C:/Users/chang/Downloads/LR_TEMPLATE.pptx";

const App = () => {
  const [user, setUser] = useState(null);
  const [step, setStep] = useState(0); 
  const [templateFile, setTemplateFile] = useState(null);
  const [placeholders, setPlaceholders] = useState([]);
  const [mediaFiles, setMediaFiles] = useState([]);
  const [formData, setFormData] = useState({});
  const [isProcessing, setIsProcessing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadingMessage, setLoadingMessage] = useState("");
  const [error, setError] = useState(null);
  const [dragActive, setDragActive] = useState(false);
  const [libsLoaded, setLibsLoaded] = useState(false);
  const [isOwnerMode, setIsOwnerMode] = useState(false); 
  const [showResetConfirm, setShowResetConfirm] = useState(false);
  const [usingPreset, setUsingPreset] = useState(false);

  // --- Auth ---
  useEffect(() => {
    const initAuth = async () => {
      try {
        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
          await signInWithCustomToken(auth, __initial_auth_token);
        } else {
          await signInAnonymously(auth);
        }
      } catch (err) {
        console.error("Auth failed", err);
        setError("Could not authenticate. Please refresh.");
      }
    };
    initAuth();
    const unsubscribe = onAuthStateChanged(auth, setUser);
    return () => unsubscribe();
  }, []);

  // --- Data Fetching (Cloud + Preset) ---
  useEffect(() => {
    if (!user) return;
    const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'config', 'main');

    // Helper to load preset if cloud is empty
    const tryLoadPreset = async () => {
        try {
            setLoadingMessage("Checking for preset template...");
            const response = await fetch(PRESET_TEMPLATE_PATH);
            if (response.ok) {
                const buffer = await response.arrayBuffer();
                console.log("Preset template found.");
                setUsingPreset(true);
                processExistingTemplate(buffer);
            } else {
                console.log("No preset template found (404), going to upload mode.");
                setStep(1);
            }
        } catch (e) {
            console.log("Preset fetch failed, going to upload mode.");
            setStep(1);
        } finally {
            setLoadingMessage("");
        }
    };

    let unsubscribe;
    try {
        unsubscribe = onSnapshot(docRef, async (snapshot) => {
            // Priority 1: Cloud Template (if exists)
            if (snapshot.exists() && !isOwnerMode) {
                const data = snapshot.data();
                try {
                    let fullBase64 = "";
                    if (data.chunkCount && data.chunkCount > 0) {
                        setLoadingMessage("Downloading cloud template...");
                        const chunkPromises = [];
                        for (let i = 0; i < data.chunkCount; i++) {
                            const chunkRef = doc(db, 'artifacts', appId, 'public', 'data', 'config', `chunk_${i}`);
                            chunkPromises.push(getDoc(chunkRef));
                        }
                        const chunkDocs = await Promise.all(chunkPromises);
                        const sortedChunks = chunkDocs.map((d, i) => ({ 
                            index: i, 
                            data: d.exists() ? d.data().content : "" 
                        }));
                        fullBase64 = sortedChunks.reduce((acc, chunk) => acc + chunk.data, "");
                    } else if (data.templateBase64) {
                        fullBase64 = data.templateBase64;
                    }

                    if (fullBase64) {
                        const arrayBuffer = base64ToArrayBuffer(fullBase64);
                        processExistingTemplate(arrayBuffer);
                        setUsingPreset(false);
                    } else {
                        // Cloud record exists but empty? Try preset.
                        tryLoadPreset();
                    }
                } catch (e) {
                    console.error("Failed to load saved template", e);
                    tryLoadPreset(); 
                } finally {
                    setLoadingMessage("");
                }
            } 
            // Priority 2: Preset Template (if cloud empty)
            else if (!isOwnerMode) {
                tryLoadPreset();
            }
        }, (err) => {
            console.error("Firestore Error", err);
            tryLoadPreset(); 
        });
    } catch (e) {
        tryLoadPreset();
    }
    return () => { if (unsubscribe) unsubscribe(); };
  }, [user, isOwnerMode]); 

  // --- Library Loading ---
  useEffect(() => {
    const loadLibraries = async () => {
      try {
        const loadScript = (src, globalCheck) => {
          return new Promise((resolve, reject) => {
            if (globalCheck()) { resolve(); return; }
            if (document.querySelector(`script[src="${src}"]`)) {
              let attempts = 0;
              const interval = setInterval(() => {
                attempts++;
                if (globalCheck()) { clearInterval(interval); resolve(); }
                else if (attempts > 20) { clearInterval(interval); resolve(); }
              }, 100);
              return;
            }
            const script = document.createElement('script');
            script.src = src;
            script.onload = () => { if (globalCheck()) resolve(); else setTimeout(resolve, 100); };
            script.onerror = reject;
            document.head.appendChild(script);
          });
        };
        await Promise.all([
          loadScript('https://unpkg.com/pizzip@3.1.4/dist/pizzip.js', () => !!window.PizZip),
          loadScript('https://cdnjs.cloudflare.com/ajax/libs/docxtemplater/3.42.0/docxtemplater.js', () => !!window.Docxtemplater || !!window.docxtemplater)
        ]);
        if (!window.PizZip || (!window.Docxtemplater && !window.docxtemplater)) throw new Error("Scripts loaded but global variables are missing.");
        setLibsLoaded(true);
      } catch (err) {
        setError("Failed to load necessary processing libraries. Please check your internet connection and refresh.");
      }
    };
    loadLibraries();
  }, []);

  // --- Helpers ---
  const arrayBufferToBase64 = (buffer) => {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
    return window.btoa(binary);
  };
  const base64ToArrayBuffer = (base64) => {
    const binary_string = window.atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) bytes[i] = binary_string.charCodeAt(i);
    return bytes.buffer;
  };
  const createBlobUrl = (data, type = 'image/png') => {
      const blob = new Blob([data], { type });
      return URL.createObjectURL(blob);
  };

  // --- File Processing ---

  const analyzeTemplate = (arrayBuffer) => {
    try {
      if (!window.PizZip) return { tags: [], media: [] };
      const zip = new window.PizZip(arrayBuffer);
      const files = zip.files;
      const tags = new Set();
      const media = [];
      const regex = /{{(.*?)}}/g;

      // 1 inch = 914400 EMUs. Use a slightly lower threshold (approx 0.99 inch) to be safe against rounding.
      const EMU_THRESHOLD = 910000;
      const allowedMediaNames = new Set();
      
      const parser = new DOMParser();

      const getSlideRels = (slideIndex) => {
          const relsPath = `ppt/slides/_rels/slide${slideIndex}.xml.rels`;
          const rels = {};
          if (files[relsPath]) {
              const relsContent = files[relsPath].asText();
              const relsDoc = parser.parseFromString(relsContent, "application/xml");
              const relationships = relsDoc.getElementsByTagName("Relationship");
              for (let i = 0; i < relationships.length; i++) {
                  const id = relationships[i].getAttribute("Id");
                  const target = relationships[i].getAttribute("Target");
                  if (id && target) rels[id] = target;
              }
          }
          return rels;
      };

      Object.keys(files).forEach(path => {
        if (path.startsWith('ppt/slides/slide') && path.endsWith('.xml')) {
            const slideMatch = path.match(/slide(\d+)\.xml/);
            if (!slideMatch) return;
            const slideIndex = slideMatch[1];
            const content = files[path].asText();

            // 1. Text Placeholders (Regex is fine for text)
            let match;
            while ((match = regex.exec(content)) !== null) {
                const cleanTag = match[1].replace(/<[^>]+>/g, '').trim();
                if (cleanTag) tags.add(cleanTag);
            }

            // 2. Image Placeholders (DOM Parser for robustness)
            const xmlDoc = parser.parseFromString(content, "application/xml");
            const rels = getSlideRels(slideIndex);
            
            // "p:pic" is the standard tag for pictures in PresentationML
            const pics = xmlDoc.getElementsByTagName("p:pic");
            
            for (let i = 0; i < pics.length; i++) {
                const pic = pics[i];
                
                // Navigate to size: p:spPr -> a:xfrm -> a:ext
                const spPr = pic.getElementsByTagName("p:spPr")[0];
                if (!spPr) continue;
                
                const xfrm = spPr.getElementsByTagName("a:xfrm")[0];
                if (!xfrm) continue;
                
                const ext = xfrm.getElementsByTagName("a:ext")[0];
                if (!ext) continue;
                
                const cx = parseInt(ext.getAttribute("cx"));
                const cy = parseInt(ext.getAttribute("cy"));

                // Navigate to Embed ID: p:blipFill -> a:blip
                const blipFill = pic.getElementsByTagName("p:blipFill")[0];
                if (!blipFill) continue;
                
                const blip = blipFill.getElementsByTagName("a:blip")[0];
                if (!blip) continue;
                
                // Get relationship ID (usually r:embed)
                const rId = blip.getAttribute("r:embed");
                if (!rId) continue;

                // Check Size Filter
                if (cx >= EMU_THRESHOLD && cy >= EMU_THRESHOLD) {
                    const targetPath = rels[rId];
                    if (targetPath) {
                        const filename = targetPath.split('/').pop();
                        allowedMediaNames.add(filename);
                    }
                }
            }
        }
      });
      
      Object.keys(files).forEach(path => {
          if (path.startsWith('ppt/media/')) {
            const filename = path.split('/').pop();
            const extension = filename.split('.').pop().toLowerCase();
            if (['png', 'jpeg', 'jpg', 'gif'].includes(extension)) {
                if (allowedMediaNames.has(filename)) {
                    const content = files[path].asUint8Array();
                    media.push({
                        path: path,
                        name: filename,
                        originalData: content,
                        newData: null,
                        previewUrl: createBlobUrl(content)
                    });
                }
            }
          }
      });
      
      return { tags: Array.from(tags), media };
    } catch (e) {
      console.error("Error analyzing template", e);
      throw e;
    }
  };

  const processExistingTemplate = (arrayBuffer) => {
    if (!libsLoaded) {
       setTimeout(() => processExistingTemplate(arrayBuffer), 500);
       return;
    }
    try {
      const { tags, media } = analyzeTemplate(arrayBuffer);
      setTemplateFile(arrayBuffer);
      setPlaceholders(tags);
      setMediaFiles(media);
      const initialData = {};
      tags.forEach(tag => initialData[tag] = formData[tag] || '');
      setFormData(initialData);
      setStep(2);
      setIsProcessing(false);
    } catch (err) {
      setError("The saved template is corrupted or incompatible.");
    }
  };

  const processNewFile = (file) => {
    setError(null);
    if (!libsLoaded) { setError("System initializing..."); return; }
    if (!file.name.endsWith('.pptx')) { setError("Please upload a .pptx file."); return; }
    if (file.size > MAX_FILE_SIZE_BYTES) { setError(`File too large. Max 5MB.`); return; }

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const buffer = e.target.result;
        const { tags, media } = analyzeTemplate(buffer);
        if (tags.length === 0 && media.length === 0) {
          setError("No valid placeholders found (Images must be > 1x1 inch).");
          return;
        }
        setTemplateFile(buffer);
        setPlaceholders(tags);
        setMediaFiles(media);
        setIsOwnerMode(true); 
        setUsingPreset(false);
      } catch (err) {
        setError("Failed to parse the PowerPoint file.");
      }
    };
    reader.readAsArrayBuffer(file);
  };

  const handleSaveToCloud = async () => {
      if (!user || !templateFile) return;
      setIsSaving(true);
      setError(null);
      try {
          const base64 = arrayBufferToBase64(templateFile);
          const chunks = [];
          for (let i = 0; i < base64.length; i += CHUNK_SIZE_CHARS) {
              chunks.push(base64.substring(i, i + CHUNK_SIZE_CHARS));
          }
          const chunkPromises = chunks.map((chunk, index) => {
              return setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'config', `chunk_${index}`), {
                  content: chunk, index: index
              });
          });
          await Promise.all(chunkPromises);
          await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'config', 'main'), {
              chunkCount: chunks.length,
              totalSize: templateFile.byteLength,
              updatedAt: new Date().toISOString(),
              placeholderCount: placeholders.length
          });
          setIsOwnerMode(false); 
      } catch (err) {
          setError("Failed to save. Try again.");
      } finally {
          setIsSaving(false);
      }
  };

  // --- Modal Logic ---
  const triggerChangeTemplate = () => setShowResetConfirm(true);
  
  const confirmChangeTemplate = () => {
      setIsOwnerMode(true);
      setTemplateFile(null);
      setStep(1);
      setShowResetConfirm(false);
      setUsingPreset(false); // Force out of preset mode if user wants to change it
  };

  const handleImageUpload = (index, file) => {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
          const newData = e.target.result; 
          const newMediaFiles = [...mediaFiles];
          newMediaFiles[index].newData = newData;
          newMediaFiles[index].previewUrl = createBlobUrl(newData);
          setMediaFiles(newMediaFiles);
      };
      reader.readAsArrayBuffer(file);
  };

  const resetImage = (index) => {
      const newMediaFiles = [...mediaFiles];
      newMediaFiles[index].newData = null;
      newMediaFiles[index].previewUrl = createBlobUrl(newMediaFiles[index].originalData);
      setMediaFiles(newMediaFiles);
  };

  const preProcessTemplate = (zip) => {
    const files = zip.files;
    const tagRegex = /{{([^{}]*)}}/g;
    Object.keys(files).forEach(path => {
      if (path.startsWith('ppt/slides/slide') && path.endsWith('.xml')) {
        let content = files[path].asText();
        const newContent = content.replace(tagRegex, (match, innerContent) => {
           const cleanTag = innerContent.replace(/<[^>]+>/g, '').trim();
           return `{{${cleanTag}}}`;
        });
        if (newContent !== content) zip.file(path, newContent);
      }
    });
    return zip;
  };

  const generatePresentation = () => {
    setIsProcessing(true);
    setError(null);
    setTimeout(() => {
      try {
        const PizZip = window.PizZip;
        const Docxtemplater = window.Docxtemplater || window.docxtemplater;
        if (!PizZip || !Docxtemplater) throw new Error("Libraries missing");

        let zip = new PizZip(templateFile);
        
        mediaFiles.forEach(media => {
            if (media.newData) zip.file(media.path, media.newData);
        });

        zip = preProcessTemplate(zip);
        const doc = new Docxtemplater(zip, {
          paragraphLoop: true, linebreaks: true, delimiters: { start: '{{', end: '}}' }, nullGetter: () => "" 
        });

        doc.render(formData);
        const out = doc.getZip().generate({
          type: "blob", mimeType: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        });

        const url = window.URL.createObjectURL(out);
        const a = document.createElement('a');
        a.href = url;
        a.download = "LateResponse44_Presentation.pptx";
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 100);
        setStep(3);
      } catch (error) {
        setError("Error generating file. Please check your inputs.");
      } finally {
        setIsProcessing(false);
      }
    }, 800); 
  };

  // --- UI ---
  const handleDrag = (e) => { e.preventDefault(); e.stopPropagation(); if (e.type === "dragenter" || e.type === "dragover") setDragActive(true); else setDragActive(false); };
  const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); setDragActive(false); if (e.dataTransfer.files?.[0]) processNewFile(e.dataTransfer.files[0]); };
  const handleInputChange = (tag, value) => setFormData(prev => ({ ...prev, [tag]: value }));

  if (step === 0 || loadingMessage) {
      return (
          <div className="min-h-screen bg-slate-50 flex items-center justify-center">
              <div className="flex flex-col items-center gap-4">
                  <Loader2 className="w-8 h-8 text-indigo-600 animate-spin" />
                  <p className="text-slate-500 font-medium">{loadingMessage || "Loading LateResponse44..."}</p>
              </div>
          </div>
      );
  }

  return (
    <div className="min-h-screen bg-slate-50 text-slate-900 font-sans selection:bg-indigo-100 selection:text-indigo-900 relative">
      
      {/* Confirmation Modal */}
      {showResetConfirm && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 animate-in fade-in duration-200">
          <div className="bg-white rounded-2xl shadow-xl max-w-md w-full p-6 transform transition-all scale-100">
            <div className="flex items-center gap-4 mb-4 text-red-600">
              <div className="p-3 bg-red-50 rounded-full">
                <AlertTriangle className="w-6 h-6" />
              </div>
              <h3 className="text-lg font-bold text-slate-900">Replace Template?</h3>
            </div>
            <p className="text-slate-600 mb-6">
              {usingPreset 
                ? "You are currently using the default 'Preset' template included with the site. Uploading a new one will override it for all users."
                : "This will remove the current cloud-saved template for all users of this application. You will need to upload a new one."
              }
            </p>
            <div className="flex justify-end gap-3">
              <button 
                onClick={ () => setShowResetConfirm(false)}
                className="px-4 py-2 text-slate-600 font-medium hover:bg-slate-50 rounded-lg transition-colors"
              >
                Cancel
              </button>
              <button 
                onClick={confirmChangeTemplate}
                className="px-4 py-2 bg-red-600 text-white font-medium rounded-lg hover:bg-red-700 transition-colors shadow-sm"
              >
                Yes, Replace It
              </button>
            </div>
          </div>
        </div>
      )}

      <header className="bg-white border-b border-slate-200 sticky top-0 z-10">
        <div className="max-w-5xl mx-auto px-6 h-16 flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className="bg-indigo-600 p-2 rounded-lg"><LayoutTemplate className="w-5 h-5 text-white" /></div>
            <h1 className="text-xl font-bold tracking-tight text-slate-800">LateResponse44</h1>
          </div>
          <div className="flex items-center gap-4 text-sm text-slate-500">
            {step === 1 && !templateFile && <span className="font-semibold text-indigo-600">Setup Mode</span>}
            {step >= 2 && (
                <span className={`flex items-center gap-2 px-3 py-1 rounded-full text-xs font-semibold ${usingPreset ? 'bg-blue-50 text-blue-700' : 'bg-green-50 text-green-700'}`}>
                    <Cloud className="w-3 h-3"/> {usingPreset ? 'Preset Template' : 'Cloud Template'}
                </span>
            )}
          </div>
        </div>
      </header>
      <main className="max-w-3xl mx-auto px-6 py-12">
        {error && (
          <div className="mb-8 p-4 bg-red-50 border border-red-200 rounded-xl flex items-start gap-3 animate-fade-in break-words">
            <AlertCircle className="w-5 h-5 text-red-600 mt-0.5 flex-shrink-0" />
            <div className="flex-1 min-w-0">
              <h3 className="text-sm font-semibold text-red-800">Something went wrong</h3>
              <p className="text-sm text-red-600 mt-1">{error}</p>
            </div>
            <button onClick={ () => setError(null)}><X className="w-4 h-4 text-red-400 hover:text-red-600" /></button>
          </div>
        )}

        {step === 1 && (
          <div className="animate-in fade-in slide-in-from-bottom-4 duration-500">
            <div className="text-center mb-10">
              <h2 className="text-3xl font-bold text-slate-900 mb-4">Setup LateResponse44</h2>
              <p className="text-lg text-slate-600 max-w-lg mx-auto leading-relaxed">
                Upload a PowerPoint template to get started. <br/>
                <span className="text-sm text-slate-400">
                    Or place <code>template.pptx</code> in your public folder to use a preset.
                </span>
              </p>
            </div>
            {!templateFile ? (
                <div className={`relative border-2 border-dashed rounded-3xl p-12 text-center transition-all duration-200 ease-out ${dragActive ? 'border-indigo-500 bg-indigo-50/50 scale-[1.02]' : 'border-slate-300 bg-white hover:border-indigo-400 hover:bg-slate-50'}`} onDragEnter={handleDrag} onDragLeave={handleDrag} onDragOver={handleDrag} onDrop={handleDrop}>
                <input type="file" className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" onChange={(e) => e.target.files?.[0] && processNewFile(e.target.files[0])} accept=".pptx" disabled={!libsLoaded} />
                <div className="flex flex-col items-center pointer-events-none">
                    <div className={`p-4 rounded-full mb-6 ${dragActive ? 'bg-indigo-100 text-indigo-600' : 'bg-slate-100 text-slate-400' }`}><Upload className="w-8 h-8" /></div>
                    <h3 className="text-xl font-semibold text-slate-900 mb-2">Drop your .pptx file here</h3>
                    <p className="text-slate-500 mb-4">or click to browse</p>
                    <div className="flex gap-2 items-center text-xs text-slate-400 uppercase tracking-wider font-semibold"><FileText className="w-4 h-4" /> Max 5MB</div>
                </div>
                </div>
            ) : (
                <div className="bg-white border border-slate-200 rounded-2xl p-8 text-center shadow-sm">
                    <div className="inline-flex items-center justify-center w-16 h-16 bg-indigo-100 text-indigo-600 rounded-full mb-4"><CheckCircle className="w-8 h-8" /></div>
                    <h3 className="text-xl font-bold text-slate-900 mb-2">Template Processed</h3>
                    <div className="flex justify-center gap-6 mb-8 text-sm text-slate-600">
                        <div><span className="font-bold text-slate-900 text-lg block">{placeholders.length}</span> Text Fields</div>
                        <div className="w-px bg-slate-200"></div>
                        <div><span className="font-bold text-slate-900 text-lg block">{mediaFiles.length}</span> Images Found</div>
                    </div>
                    <div className="flex items-center justify-center gap-3">
                        <button onClick={() => setTemplateFile(null)} className="px-6 py-2.5 rounded-lg border border-slate-300 text-slate-700 font-medium hover:bg-slate-50 transition-colors">Cancel</button>
                        <button onClick={handleSaveToCloud} disabled={isSaving} className="flex items-center gap-2 px-6 py-2.5 rounded-lg bg-indigo-600 text-white font-medium hover:bg-indigo-700 transition-all shadow-md hover:shadow-lg disabled:opacity-70 disabled:cursor-wait">
                            {isSaving ? <Loader2 className="w-4 h-4 animate-spin"/> : <Save className="w-4 h-4" />}
                            {isSaving ? "Uploading Chunks..." : "Save & Publish App"}
                        </button>
                    </div>
                </div>
            )}
          </div>
        )}

        {step === 2 && (
          <div className="animate-in fade-in slide-in-from-bottom-4 duration-500">
            <div className="flex flex-col md:flex-row md:items-center justify-between mb-8 gap-4">
              <div><h2 className="text-2xl font-bold text-slate-900">Enter Details</h2><p className="text-slate-500 mt-1">Fill out the form below.</p></div>
              <button onClick={triggerChangeTemplate} className="flex items-center gap-2 text-xs font-semibold text-slate-400 hover:text-red-500 transition-colors px-3 py-1.5 rounded-lg border border-transparent hover:border-red-100 hover:bg-red-50 self-start md:self-auto"><Trash2 className="w-3.5 h-3.5" /> Change Template</button>
            </div>
            <div className="space-y-6">
                {placeholders.length > 0 && (
                    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden">
                        <div className="px-6 py-4 bg-slate-50 border-b border-slate-200 font-semibold text-slate-700 flex items-center gap-2"><FileText className="w-4 h-4" /> Text Fields</div>
                        <div className="p-8 grid gap-6 md:grid-cols-2">
                            {placeholders.map((tag) => (
                            <div key={tag} className="flex flex-col gap-2 group">
                                <label className="text-sm font-semibold text-slate-700 uppercase tracking-wide group-focus-within:text-indigo-600 transition-colors">{tag.replace(/_/g, ' ')}</label>
                                <input type="text" value={formData[tag]} onChange={(e) => handleInputChange(tag, e.target.value)} placeholder={`Enter ${tag}...`} className="w-full px-4 py-3 rounded-lg bg-slate-50 border border-slate-200 text-slate-900 placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500/20 focus:border-indigo-500 transition-all"/>
                            </div>
                            ))}
                        </div>
                    </div>
                )}
                {mediaFiles.length > 0 && (
                     <div className="bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden">
                        <div className="px-6 py-4 bg-slate-50 border-b border-slate-200 font-semibold text-slate-700 flex items-center gap-2"><ImageIcon className="w-4 h-4" /> Image Replacements</div>
                        <div className="p-8 grid gap-6 sm:grid-cols-2 lg:grid-cols-3">
                            {mediaFiles.map((media, idx) => (
                                <div key={idx} className="border border-slate-200 rounded-xl p-4 bg-slate-50/50 flex flex-col gap-3">
                                    <div className="aspect-video w-full bg-slate-200 rounded-lg overflow-hidden relative group">
                                        <img src={media.previewUrl} alt="Preview" className="w-full h-full object-cover" />
                                        {media.newData && (<div className="absolute inset-0 bg-black/50 flex items-center justify-center text-white text-xs font-semibold">Replaced</div>)}
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <span className="text-xs text-slate-400 truncate max-w-[100px]" title={media.name}>{media.name}</span>
                                        <div className="flex gap-2">
                                            {media.newData && (<button onClick={ () => resetImage(idx)} className="p-1.5 text-slate-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition-colors" title="Reset"><Trash2 className="w-4 h-4" /></button>)}
                                            <label className="cursor-pointer p-1.5 text-indigo-600 hover:bg-indigo-50 rounded-lg transition-colors" title="Replace"><Replace className="w-4 h-4" /><input type="file" className="hidden" accept="image/*" onChange={(e) => handleImageUpload(idx, e.target.files?.[0])}/></label>
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                     </div>
                )}
                <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-8 flex justify-end">
                    <button onClick={generatePresentation} disabled={isProcessing} className={`flex items-center gap-2 px-6 py-3 rounded-lg font-semibold text-white shadow-lg shadow-indigo-500/30 transition-all ${isProcessing ? 'bg-indigo-400 cursor-wait' : 'bg-indigo-600 hover:bg-indigo-700 hover:shadow-indigo-500/40 hover:-translate-y-0.5 active:translate-y-0'}`}>
                    {isProcessing ? <><RefreshCw className="w-5 h-5 animate-spin" /> Generating...</> : <><Download className="w-5 h-5" /> Download Presentation</>}
                    </button>
                </div>
            </div>
          </div>
        )}

        {step === 3 && (
          <div className="text-center animate-in zoom-in-95 duration-500 py-12">
            <div className="inline-flex items-center justify-center w-20 h-20 bg-green-100 text-green-600 rounded-full mb-6"><CheckCircle className="w-10 h-10" /></div>
            <h2 className="text-3xl font-bold text-slate-900 mb-4">Download Ready!</h2>
            <p className="text-lg text-slate-600 max-w-md mx-auto mb-8">Your presentation has been generated and downloaded.</p>
            <button onClick={ () => { setStep(2); setIsProcessing(false); }} className="inline-flex items-center gap-2 px-6 py-3 rounded-lg bg-white border border-slate-300 font-semibold text-slate-700 hover:bg-slate-50 hover:border-slate-400 transition-all"><RefreshCw className="w-4 h-4" /> Create Another</button>
          </div>
        )}
      </main>
    </div>
  );
};

export default App;